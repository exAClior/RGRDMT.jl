var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"Modules = [RGRDMT]\nOrder = [:type, :function]","category":"page"},{"location":"api/#RGRDMT.CGmapping_from_AL-Tuple{TensorKit.AbstractTensorMap, Integer, Integer}","page":"API","title":"RGRDMT.CGmapping_from_AL","text":"CGmapping_from_AL(AL::AbstractTensorMap, k0::Integer, n::Integer)\n\nConstructs a CG mapping from an abstract tensor map AL.\n\nArguments\n\nAL::AbstractTensorMap: The abstract tensor map.\nk0::Integer: The value of k0.\nn::Integer: The value of n.\n\nReturns\n\nIf n == k0, returns a tuple (V0, V1, V2) where:\nV0: A matrix of size D^2 x (d^k0) representing the finite part of the CG mapping.\nV1: A sparse matrix of size D^2 x (D^2 * d) representing the left-infinite part of the CG mapping.\nV2: A sparse matrix of size D^2 x (D^2 * d) representing the right-infinite part of the CG mapping.\nIf n != k0, returns a tuple (V0, L, R) where:\nV0: A matrix of size D^2 x (d^k0) representing the finite part of the CG mapping.\nL: A matrix of size D^2 x (D^2 * d) representing the left-infinite part of the CG mapping.\nR: A matrix of size D^2 x (D^2 * d) representing the right-infinite part of the CG mapping.\n\n\n\n\n\n","category":"method"},{"location":"api/#RGRDMT.approx_ground_state-Union{Tuple{T}, Tuple{MPSKit.MPOHamiltonian{T, T1, E} where {T1<:(TensorKit.AbstractTensorMap{S, 2, 2} where S), E<:Number}, MPSKit.InfiniteMPS, Integer, Integer}} where T","page":"API","title":"RGRDMT.approx_ground_state","text":"approxgroundstate(H::MPOHamiltonian{T}, ψ_good::InfiniteMPS, d::Integer, D::Integer) where {T}\n\nApproximates the ground state of a given Hamiltonian using the variational uniform matrix product state (VUMPS) algorithm.\n\nArguments\n\nH::MPOHamiltonian{T}: The Hamiltonian for which the ground state is to be approximated.\nψ_good::InfiniteMPS: An initial guess for the ground state.\nd::Integer: The local Hilbert space dimension.\nD::Integer: The bond dimension.\n\nReturns\n\nψ_approx::InfiniteMPS: The approximate ground state.\n\n\n\n\n\n","category":"method"},{"location":"api/#RGRDMT.good_ground_state-Union{Tuple{T}, Tuple{MPSKit.MPOHamiltonian{T, T1, E} where {T1<:(TensorKit.AbstractTensorMap{S, 2, 2} where S), E<:Number}, Integer}} where T","page":"API","title":"RGRDMT.good_ground_state","text":"good_ground_state(H::MPOHamiltonian{T}, D::Integer) where {T}\n\nCompute the ground state of a given MPOHamiltonian using the VUMPS algorithm.\n\nArguments\n\nH::MPOHamiltonian{T}: The MPOHamiltonian representing the Hamiltonian of the system.\nD::Integer: The bond dimension of the MPS.\n\nReturns\n\ngroundstate: The ground state of the system.\n\n\n\n\n\n","category":"method"},{"location":"api/#RGRDMT.load_Hamiltonian-Tuple{String}","page":"API","title":"RGRDMT.load_Hamiltonian","text":"load_Hamiltonian(filename::String)\n\nLoad the Hamiltonian matrix and the exact eigenvalues from a file.\n\nThis function is only used when loading ground state MPS from MATLAB computation using VUMPS implemented here\n\nArguments\n\nfilename::String: The name of the file containing the Hamiltonian matrix.\n\nReturns\n\nH: The Hamiltonian matrix.\nEexact: The exact eigenvalues.\n\n\n\n\n\n","category":"method"},{"location":"api/#RGRDMT.load_MPS-Tuple{String, Integer}","page":"API","title":"RGRDMT.load_MPS","text":"load_MPS(filename::String, D::Integer)\n\nLoad an MPS (Matrix Product State) from a file.\n\nArguments\n\nfilename::String: The path to the file containing the MPS data.\nD::Integer: The virtual bond dimension of the MPS.\n\nReturns\n\nψ: The loaded MPS as an InfiniteMPS object.\nupperBdFromMPS: The upper bound of ground state energy achieved by the MPS.\n\n\n\n\n\n","category":"method"},{"location":"api/#RGRDMT.one_step_approx_dual-Union{Tuple{V}, Tuple{AbstractMatrix{V}, Integer}, Tuple{AbstractMatrix{V}, Integer, Any}} where V","page":"API","title":"RGRDMT.one_step_approx_dual","text":"onestepapprox_dual(h::AbstractMatrix{V}, n::Integer, optimizer=SCS.Optimizer) where {V}\n\nCompute the one-step approximation of the dual energy for a given Hamiltonian.\n\nArguments\n\nh::AbstractMatrix{V}: The Hamiltonian matrix.\nn::Integer: The number of spins.\noptimizer=SCS.Optimizer: The optimizer to use for solving the optimization problem.\n\nReturns\n\nElocTIRig::Float64: The one-step approximation of the dual energy with the lowest eigenvalue added.\nElocTI::Float64: The one-step approximation of the dual energy.\n\nExample\n\n\n\n\n\n","category":"method"},{"location":"api/#RGRDMT.two_step_approx-Union{Tuple{T}, Tuple{V}, Tuple{AbstractMatrix{V}, Integer, Integer, AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}}, Tuple{AbstractMatrix{V}, Integer, Integer, AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, Any}} where {V, T}","page":"API","title":"RGRDMT.two_step_approx","text":"two_step_approx(h::AbstractMatrix{V}, D::Integer, n::Integer,\n    W2::AbstractMatrix{T}, L2::AbstractMatrix{T}, R2::AbstractMatrix{T},\n    optimizer=SCS.Optimizer) where {V,T}\n\nApproximates a two-step Renormalization Group (RG) transformation for a given Hamiltonian h using the specified parameters.\n\nArguments\n\nh::AbstractMatrix{V}: The input Hamiltonian matrix.\nD::Integer: The bond dimension.\nn::Integer: The number of RG steps.\nW2::AbstractMatrix{T}: The second layer of the RG transformation.\nL2::AbstractMatrix{T}: The left transformation matrix for the second layer.\nR2::AbstractMatrix{T}: The right transformation matrix for the second layer.\noptimizer=SCS.Optimizer: The optimizer to use for solving the optimization problem.\n\nReturns\n\nThe objective value of the optimization problem.\n\nExample\n\n\n\n\n\n","category":"method"},{"location":"theory/#Motivation","page":"Theory","title":"Motivation","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"We want to find the ground state of a local Hamiltonian for a spin-system on some lattice.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"A spin-system is a collection spin each with Hilbert space mathbbC^d. For simplicity, we will consider spins residing on a chain with uniform distance a.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: )","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The local Hamiltonian is denoted as H = sum_i^N h_i where h_i only acts non-trivially on a few spins that are physically close together. For simplicity, we will consider a 2-local Hamiltonian H = sum_i^N h_i^(2). More concretely, we could think of the Hamiltonian having the form:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"H = sum_i^N X_iX_i+1 + Y_iY_i+1 + Z_iZ_i+1","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The ground state energy may diverge in case N rightarrow infty. Therefore, we rephrase our goal into finding the ground state energy per-site for a Hamiltonian.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"e_0 = min_ketpsi frac1N brapsi H ketpsi","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Due to translational invariance of the Hamiltonian, we would expect the ground state energy to also be reached with the following equation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"e_0 = min_ketpsi brapsi h_i^(2) ketpsi","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Since h_i^(2) has no support on spins other than the two at location i and i+1, we could safely simplify the minimization. Instread of trying to minimize e_0 over an exponentially large state ketpsi, similar result is achieved when you do the minimization over reduced density matrix on spin i and i+1, we denote it as rho^(2).","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"e_0 = min_rho^(2) tr( rho^(2) h_i^(2))","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"However, this naive reduction will bring problems because rho^(2) may not correspond to a physical state. Therefore, we need to add the constraint that rho^(2) be the reduced density matrix on two spins obtained from a reduced density matrix on three spins. This constraint alone will make the solution more physical. However, we would still improve by posting a series of constraint for our 1D example:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"rho^(i) = tr_L(rho^(i+1)) = tr_R(rho^(i+1))","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"The right most equation is referred to as the Locally Translation Invariant (LTI) conditions.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where tr_LR denotes the partial trace of the left/right most spin's Hilbert space. Using a graphical tensor network representation, we could visualize the constraints as follows:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: )[1]","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"[1]: (Kull et al., 2024)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"When the above constraints are taken into account up to n spins' reduced density matrix, we denote the all such two-spin reduce density matrix rho^(2) with set mathcalS.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"A good news is that mathcalS is a convex set. Furthermore, the e = tr(rho^(2) h_i^(2)) is a linear function and the constrains are also linear. Therefore, we could use convex optimization to find the ground state energy per-site.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"rho^(2)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"that gives the same e = tr(rho^(2) h_i^(2)) forms a hyperplane. Finding e_0 is equivalent to finding the hyperplane with lowest energy. This is visualized in the following diagram","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: )[1]","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"When we add more constraints, this amounts to cutting mathcalS. When we follow the lines of previous reasoning and adds more restrictions in the form of","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"rho^(i) = tr_L(rho^(i+1)) = tr_R(rho^(i+1))","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"we pay a price of adding exponentially more constraints since the dimension of rho^(i) is d^2i. Another observation is that not all constraints are essential to obtain the hyperplane with e = e_0. This promotes simplification to the algorithm. Rather than strictly requiring all the constraints be satisfied","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"rho^(i) = tr_L(rho^(i+1)) = tr_R(rho^(i+1))","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"we could instead do isometries and pick out part of the reduced density matrix that are closestly related to ground states. ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"(Image: )[1]","category":"page"},{"location":"reference/#Bibliography","page":"Suggested Readings and References","title":"Bibliography","text":"","category":"section"},{"location":"reference/","page":"Suggested Readings and References","title":"Suggested Readings and References","text":"Boyd, S. and Vandenberghe, L. (2004). Convex Optimization. Dl. 1 of Berichte über verteilte messysteme (Cambridge University Press).\n\n\n\nKull, I.; Schuch, N.; Dive, B. and Navascués, M. (2024). Lower Bounds on Ground-State Energies of Local Hamiltonians through the Renormalization Group. Physical Review X 14, 021008.\n\n\n\nXiang, T. (2023). Density Matrix and Tensor Network Renormalization (Cambridge University Press).\n\n\n\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = RGRDMT","category":"page"},{"location":"#Renormalization-Group-Reduced-Density-Matrix","page":"Home","title":"Renormalization Group Reduced Density Matrix","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RGRDMT.jl is a julia library for finding the lower bound to the ground state energy of a translationally invariant Hamiltonian. The library is based on the paper [1].","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1]: (Kull et al., 2024) ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This library uses Convex Optimization[2] to find the lower bound to the ground state energy by optimizing a reduced density matrix. Concepts of renormalization group[3] were employed to reduce the dimension of the problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2]: (Boyd and Vandenberghe, 2004)","category":"page"},{"location":"","page":"Home","title":"Home","text":"[3]: (Xiang, 2023)","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently, we have included tested optimizers for Convex Optimization and the package is plug-and-play. You will only need to install the package by running the following code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"RGRDMT\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"For detailed usage, please refer to the test case in test/example.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for RGRDMT.","category":"page"},{"location":"implementation/#Implementation","page":"Implementation","title":"Implementation","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The implementation consist of two parts. The first part is the convex optimization formulation of the problem. The second part is the application of the isometry to reduce the number of constraints in the convex optimization problem. ","category":"page"},{"location":"implementation/#Convex-Optimization-via-Reduced-Density-Matrix","page":"Implementation","title":"Convex Optimization via Reduced Density Matrix","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"tip: Choice of Convex Optimization Packages\nThere are two choices when it comes to convex optimization packages in Julia. The first is Convex.jl and the second is JuMP.jl. The choice of JuMP.jl is made because it avoids the cumbersome checking of convexity of our problem as indicated here. Note that if you would like to have a more accurate result, you should use Convex.jl and it is more performant when your constraints come in matrix and vector form as it ensures type stability.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"This step is carried out with function one_step_approx_dual. Instead of solving the primal problem, we solve the dual problem. The dual problem has fewer parameters (d^2(n-1)+1 vs sum_i=3^n d^2i) hence is faster to solve. It is possible to automatically convert the primal problem with Dualization.jl. However, it is time costly. We formulate the dual problem directly following Eqn [44] in [1].","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"[1]: (Kull et al., 2024)","category":"page"},{"location":"implementation/#Applying-Isometry","page":"Implementation","title":"Applying Isometry","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"This step requires us to apply the isometry and reduce dimension of the reduced density matrix. ","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"A good isometry is obtained from a variationally obtained ground state estimation of the Hamiltonian. We use the MPSKit.jl to obtain the ground state estimation. For convinence, we provide a function good_ground_state to obtain the ground state estimation. If you choose to use a pre-solved ground state estimation, you might need to trim down the virtual bond dimension of the MPS to desired value. This is achieved with approx_ground_state.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"After obtaining the ground state MPS, we use the left canonical form of the MPS to obtain the isometry. It is implemented in function CGmapping_from_AL.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Finally, with the isometry, we can reduce the dimension of the reduced density matrix. For clarify sake's we only consider the primal problem. The implementation is done in function two_step_approx.","category":"page"},{"location":"implementation/#Results","page":"Implementation","title":"Results","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"As a result, we obtain the following plot for how close the lower bound was for the ground state energy. We obtain the ground state energy for the Heisenberg XXX model H = sum_i^N X_iX_i+1 + Y_iY_i+1 + Z_iZ_i+1. The theoretical value for the ground state energy per site is e_0 = 14 - ln2. Let the ground state energy per site obtained from convex optimization with relaxed constrains be e_rlx, we define the gap of groun state energy as Delta E_relax = e_0 - e_rlx","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Replication Results Paper Results\n(Image: ) (Image: )","category":"page"}]
}
